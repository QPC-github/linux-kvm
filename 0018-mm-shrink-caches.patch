From 70a0248d93ea2d58f1d5c29b37df3296941d0d91 Mon Sep 17 00:00:00 2001
From: Arjan van de Ven <arjan@linux.intel.com>
Date: Wed, 30 Mar 2016 05:44:00 -0600
Subject: [PATCH 18/19] mm: shrink caches

memshrinker in the kvm kernel
---
 fs/drop_caches.c   | 21 +++++++++++++++++++++
 include/linux/mm.h |  3 +++
 kernel/sysctl.c    |  7 +++++++
 mm/vmscan.c        |  2 --
 4 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/fs/drop_caches.c b/fs/drop_caches.c
index d72d52b..91d506e 100644
--- a/fs/drop_caches.c
+++ b/fs/drop_caches.c
@@ -8,10 +8,12 @@
 #include <linux/writeback.h>
 #include <linux/sysctl.h>
 #include <linux/gfp.h>
+#include <linux/swap.h>
 #include "internal.h"
 
 /* A global variable is a bit ugly, but it keeps the code simple */
 int sysctl_drop_caches;
+int sysctl_shrink_caches_mb;
 
 static void drop_pagecache_sb(struct super_block *sb, void *unused)
 {
@@ -67,3 +69,22 @@ int drop_caches_sysctl_handler(struct ctl_table *table, int write,
 	}
 	return 0;
 }
+
+int shrink_caches_sysctl_handler(struct ctl_table *table, int write,
+	void __user *buffer, size_t *length, loff_t *ppos)
+{
+	int ret;
+
+	ret = proc_dointvec(table, write, buffer, length, ppos);
+	if (ret)
+		return ret;
+	if (write)
+		shrink_all_memory(1024 * 1024 / PAGE_SIZE * sysctl_shrink_caches_mb);
+
+	/*
+	 * Now that a bunch of memory is freed, empty the per cpu caches as well
+	 */
+	lru_add_drain_all();
+
+	return 0;
+}
diff --git a/include/linux/mm.h b/include/linux/mm.h
index 516e149..0efb950 100644
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -2223,6 +2223,9 @@ static inline int in_gate_area(struct mm_struct *mm, unsigned long addr)
 extern int sysctl_drop_caches;
 int drop_caches_sysctl_handler(struct ctl_table *, int,
 					void __user *, size_t *, loff_t *);
+extern int sysctl_shrink_caches_mb;
+int shrink_caches_sysctl_handler(struct ctl_table *, int,
+					void __user *, size_t *, loff_t *);
 #endif
 
 void drop_slab(void);
diff --git a/kernel/sysctl.c b/kernel/sysctl.c
index 97715fd..e6d1d4d 100644
--- a/kernel/sysctl.c
+++ b/kernel/sysctl.c
@@ -1356,6 +1356,13 @@ static struct ctl_table vm_table[] = {
 		.extra1		= &one,
 		.extra2		= &four,
 	},
+	{
+		.procname	= "shrink_caches_mb",
+		.data		= &sysctl_shrink_caches_mb,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= shrink_caches_sysctl_handler,
+	},
 #ifdef CONFIG_COMPACTION
 	{
 		.procname	= "compact_memory",
diff --git a/mm/vmscan.c b/mm/vmscan.c
index 71b1c29..09c6539 100644
--- a/mm/vmscan.c
+++ b/mm/vmscan.c
@@ -3556,7 +3556,6 @@ void wakeup_kswapd(struct zone *zone, int order, enum zone_type classzone_idx)
 	wake_up_interruptible(&pgdat->kswapd_wait);
 }
 
-#ifdef CONFIG_HIBERNATION
 /*
  * Try to free `nr_to_reclaim' of memory, system-wide, and return the number of
  * freed pages.
@@ -3594,7 +3593,6 @@ unsigned long shrink_all_memory(unsigned long nr_to_reclaim)
 
 	return nr_reclaimed;
 }
-#endif /* CONFIG_HIBERNATION */
 
 /* It's optimal to keep kswapds on the same CPUs as their memory, but
    not required for correctness.  So if the last cpu in a node goes
-- 
2.8.1

